// Package parser is responsible for translating a sequence of lexical tokens
// into an Abstract Syntax Tree (AST) conforming to the syntax of Î».c. The
// parser operates within a functional programming paradigm, leveraging monads
// to encapsulate state transformations, and striving for functional purity by
// avoiding in-place mutations.
//
// Work-In-Progress warning:
//
// This package is currently a WIP. Please do not use it while it's not fully
// implemented.
//
// Architecture:
//
// The parsing process is constructed as a pipeline of discrete, composable
// functions (parserFunc) each responsible for parsing a specific language
// construct. These functions take a State object as input, which encapsulates
// the current parser state, including the position within the token stream
// and the current AST. They return a new State along with a Result monad that
// either encapsulates the parsed ASTNode or an error.
//
// Types and Abstractions:
//
//   - State: A struct that contains the current state of the parser, including
//     the current position in the token stream, and the AST being constructed.
//   - ASTNode: Represents a node in the Abstract Syntax Tree. It holds
//     information about the type of the node (e.g., STRING, LAMBDA), its
//     associated token, and its children nodes, if any.
//
// Functional Purity:
//
// The package is designed to be functionally pure. Methods that would typically
// mutate state instead return a new modified copy of the original object. This
// is seen in methods like State.advance() and ASTNode.appendChild(), among
// others.
//
// Dependencies:
//
// This package relies heavily on the 'monad' package for handling state and
// results in a functional manner. It also uses the 'lexer' package for token
// definitions and initial lexical analysis.
//
// Usage:
//
// Parsing is initiated by calling the Parse function with an initial State
// constructed from the lexical tokens generated by the lexer.
//
//	initialState := parser.NewState(tokens)
//
//	// parse returns a monad.Result[parser.ASTNode, error] monad
//	result := parser.Parse(initialState)
//	if result.Failure() {
//	  // handle failure
//	}
//
//	ast := result.Value()
package parser

import (
	"fmt"

	"github.com/denisdubochevalier/monad"
)

// Parse is the main orchestrator function for the parser. It initiates the
// parsing process by iterating over the list of tokens encapsulated in the
// parser state. During each iteration, it delegates to specialized parsing
// functions that are responsible for handling specific tokens or constructs in
// the language. Each parsing function returns an updated parser state and a
// Result monad that encapsulates either the parsed ASTNode or an error
// detailing what went wrong.
//
// The function begins by creating an initial Result monad containing a failure
// due to an empty token list. Then, it iteratively runs the specialized parsing
// function 'eofParser', updating the state and Result value accordingly.
//
// Finally, it returns the Result monad containing either a successfully parsed
// ASTNode or an error.
//
// Parameters:
// - state: The initial parser state containing the tokens to be parsed.
//
// Returns:
// - A Result monad encapsulating either a successfully parsed ASTNode or an
// error.
func Parse(state State) monad.Result[ASTNode, error] {
	val := monad.Fail[ASTNode, error](fmt.Errorf("empty token list"))
	for !state.done() {
		val, state = monad.NewState[State, monad.Result[ASTNode, error]](
			eofParser,
		).Run(state)
	}
	return val
}
